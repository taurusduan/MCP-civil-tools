# MCP Server 開發架構

## 架構概述
- 基於FastAPI框架實現
- 使用 @mcp.tool() 裝飾器註冊工具函數
- 統一輸入輸出格式： {"success": bool, "data": any, "message": str}

## 工具開發規範
1. 函數註冊   
   - 必須使用 @mcp.tool() 裝飾器
   - 函數名稱應清晰描述工具功能
   - 參數需明確指定類型
2. 輸入輸出   
   - 輸入參數需有默認值
   - 返回值必須符合統一格式
   - 錯誤訊息應清晰明確
3. 文件規範   
   - 每個工具函數必須包含docstring
   - 說明功能、參數、返回值及範例
   - 使用中文註解
4. 錯誤處理   
   - 使用try-except捕獲異常
   - 返回錯誤時success=False
   - 錯誤訊息應包含詳細原因
5. 類型提示   
   - 所有參數需有類型提示
   - 返回值類型應明確
   - 使用自定義類型時需導入

## 最佳實踐
- 工具函數應保持單一職責
- 複雜計算應拆分到util模組
- 常用查詢函數應提供列表工具
- 遵循PEP8代碼風格

---

## 進階通用規範補充

### 1. API 版本管理
- **策略**: 所有 API 需明確標註版本號，以利未來升級與相容性維護。常見策略包含：
    - **URL 路徑版本控制**: 例如 `/api/v1/users`、`/api/v2/users`。
        - **優點**: 直觀易懂，瀏覽器和客戶端易於實現和快取。
        - **缺點**: 可能導致 URL 變長，當版本變更頻繁時，路由管理可能變得複雜。
    - **HTTP Header 版本控制**: 例如 `Accept: application/vnd.company.v1+json` 或自訂 Header `X-API-Version: 1`。
        - **優點**: URL 保持簡潔，更符合 RESTful 原則中的資源表述。
        - **缺點**: 客戶端實現稍複雜，快取機制可能不如 URL 路徑版本控制直接。
- **選擇考量**: 根據團隊熟悉度、專案規模及客戶端特性選擇合適的策略。無論選擇何種方式，都應在 API 文件中明確說明。

### 2. 統一日誌紀錄與錯誤追蹤
- **日誌格式與內容**: 必須統一採用結構化日誌格式（如 JSON），方便機器解析與查詢。每條日誌應至少包含：
    - 時間戳 (Timestamp)
    - 日誌級別 (Log Level): 如 DEBUG, INFO, WARNING, ERROR, CRITICAL。
    - **關聯 ID (Correlation ID)**: 用於追蹤單一請求在不同服務或模組間的完整流程。
    - 服務/模組名稱
    - 請求資訊 (如 HTTP 方法, URL, IP 位址, User Agent)
    - 回應資訊 (如 HTTP 狀態碼)
    - 錯誤堆疊 (Stack Trace) (若為錯誤日誌)
    - 具體訊息
- **日誌級別**: 合理使用日誌級別，例如：
    - `DEBUG`: 開發階段用於詳細追蹤。
    - `INFO`: 記錄系統正常運行的關鍵事件。
    - `WARNING`: 預期外的狀況，但不影響當前請求處理。
    - `ERROR`: 發生錯誤，導致當前請求處理失敗。
    - `CRITICAL`: 嚴重錯誤，可能導致系統整體不可用。
- **錯誤追蹤服務**: 建議整合第三方錯誤追蹤服務（如 Sentry、Rollbar），以利即時監控、告警、問題追蹤與回報。

### 3. 測試與 CI/CD 流程
- **測試類型**: 所有功能需具備：
    - **單元測試 (Unit Tests)**: 針對最小可測試單元（如函數、方法）進行驗證。
    - **整合測試 (Integration Tests)**: 驗證模組間或服務間的互動是否正確。
    - (可選) **端對端測試 (End-to-End Tests)**: 模擬真實用戶場景進行測試。
- **測試覆蓋率**: 設定合理的測試覆蓋率目標（例如，核心模組 >80%），並持續追蹤。
- **CI/CD 流程**: 建議配置自動化持續整合/持續部署 (CI/CD) 流程（如 GitHub Actions、GitLab CI、Jenkins）：
    - 自動化建置 (Build)
    - 自動化測試執行
    - 自動化部署至不同環境 (開發、測試、生產)
    - 程式碼品質掃描 (如 SonarQube)

### 4. 參數驗證與安全性建議
- **輸入驗證**: 所有來自外部的輸入（API 參數、請求體、Header 等）必須進行嚴格驗證：
    - **型別驗證**: 確保資料符合預期型別 (字串、數字、布林等)。
    - **格式驗證**: 如 Email、日期、URL 格式。
    - **範圍驗證**: 如數字大小、字串長度。
    - **白名單驗證**: 限制輸入值在預期集合內。
    - 建議採用 `pydantic` (FastAPI 內建整合) 或 `Cerberus` 等驗證庫。
- **常見威脅防護**: 針對常見 Web 應用程式安全威脅進行防護：
    - **SQL 注入 (SQL Injection)**: 使用參數化查詢或 ORM。
    - **跨站腳本攻擊 (XSS)**: 對輸出內容進行適當編碼或過濾。
    - **跨站請求偽造 (CSRF)**: 使用 CSRF Token。
    - **輸入未經驗證的重定向與轉發**。
    - **安全設定錯誤 (Security Misconfiguration)**。
    - 參考 OWASP Top 10 等安全指南。
- **輸出安全**: 輸出錯誤訊息時，避免洩漏敏感資訊（如堆疊追蹤、內部路徑、資料庫結構）。提供通用的錯誤提示，詳細錯誤記錄在內部日誌。
- **身份驗證與授權**: 
    - 實作強固的身份驗證機制 (如 OAuth 2.0, JWT)。
    - 實施最小權限原則進行授權，確保用戶只能存取其被允許的資源與操作。
    - API 金鑰或 Token 應透過安全通道傳輸 (HTTPS) 並妥善保管。
- **HTTPS**: 強制使用 HTTPS 保護資料傳輸安全。
- **安全標頭 (Security Headers)**: 設定如 `Content-Security-Policy`, `X-Content-Type-Options`, `X-Frame-Options`, `Strict-Transport-Security` 等 HTTP 安全標頭。

### 5. 多語系支援
- 回應訊息建議支援多語系（如 zh-TW、en-US），可依用戶需求切換。
- 可採用 i18n 套件或自訂語系字典。

### 6. 文件與維護
- 所有 API 需具備完整 Swagger/OpenAPI 文件，並隨版本更新。
- 重要設計決策、規範與注意事項需記錄於專案文件。

### 7. 其他最佳實踐

#### 7.1 組態管理 (Configuration Management)
- **外部化組態**: 應用程式的組態（如資料庫連線字串、API 金鑰、第三方服務端點、功能開關等）應與程式碼分離。
    - 可使用環境變數、獨立的組態檔案 (如 `.env`, `config.ini`, `config.yaml`, `config.json`) 或專門的組態服務。
- **環境特定組態**: 針對不同環境（開發、測試、預備、生產）提供不同的組態設定。
- **避免硬編碼**: 嚴禁在程式碼中硬編碼敏感資訊或環境特定的設定值。
- **版本控制**: 組態檔案（非敏感部分）應納入版本控制，敏感資訊可透過環境變數或加密方式管理。

#### 7.2 相依性管理 (Dependency Management)
- **明確版本**: 專案的所有外部相依套件及其版本必須明確記錄（例如 Python 的 `requirements.txt` 搭配 `pip freeze`，或使用 `Poetry`、`PDM` 等工具管理 `pyproject.toml`）。
- **虛擬環境**: 強烈建議為每個專案使用獨立的虛擬環境（如 `venv`, `conda`），以隔離相依性並避免版本衝突。
- **定期更新**: 定期檢查並更新相依套件至最新穩定版本，以獲取安全性修補和功能改進。注意更新可能帶來的破壞性變更。
- **最小化相依**: 僅引入專案實際需要的套件，避免不必要的相依性增加複雜度和潛在風險。
- **了解傳遞相依性 (Transitive Dependencies)**: 注意專案直接相依的套件可能引入的其他間接相依套件。

#### 7.3 程式碼審查 (Code Review)
- **強制執行**: 所有提交至主要分支的程式碼變更都應經過至少一位其他團隊成員的審查。
- **審查指南**: 建立清晰的程式碼審查指南，明確審查的重點（如功能正確性、程式碼風格、可讀性、效能、安全性、測試覆蓋率等）。
- **建設性回饋**: 審查者應提供具體、可操作且具建設性的回饋。
- **工具輔助**: 使用靜態分析工具 (Linters 如 Flake8, Pylint; Formatters 如 Black, Ruff) 在審查前自動檢查程式碼風格和潛在問題。
- **及時審查**: 盡快進行程式碼審查，避免阻塞開發流程。

#### 7.4 既有原則重申
- **模組化設計**: 保持模組化設計，便於擴充與維護。
- **設計原則**: 遵循單一職責原則 (SRP)、高內聚低耦合原則等軟體設計原則。
- **持續重構**: 定期檢討與優化架構和程式碼，根據實際需求調整規範，償還技術債。
